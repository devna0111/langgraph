# 벡터 데이터베이스 비교 가이드

## 1. 개요

### 벡터 데이터베이스란?
텍스트, 이미지 등을 고차원 벡터(숫자 배열)로 변환하여 저장하고, 의미적 유사도를 기반으로 검색하는 데이터베이스

### 주요 사용 사례
- RAG (Retrieval-Augmented Generation)
- 의미 기반 문서 검색
- 추천 시스템
- 이미지/텍스트 유사도 검색

---

## 2. 주요 벡터 DB 비교

### 2.1 Pinecone

**특징**:
- 완전 관리형 클라우드 서비스 (SaaS)
- 설치/관리 불필요
- 자동 스케일링

**장점**:
- 설정이 가장 간단
- 운영 부담 없음
- 높은 안정성

**단점**:
- 비용 발생 (무료 티어 제한적)
- 온프레미스 불가능
- 벤더 종속성

**코드 예시**:
```python
import pinecone

pinecone.init(api_key="your-api-key")
index = pinecone.Index("my-index")

# 벡터 저장
index.upsert(vectors=[
    ("id1", [0.1, 0.2, 0.3], {"text": "문서 내용"})
])

# 검색
results = index.query(vector=[0.1, 0.2, 0.3], top_k=5)
```

**적합한 경우**:
- 빠른 프로토타이핑
- 운영 리소스 부족
- 클라우드 네이티브 환경

---

### 2.2 Qdrant

**특징**:
- Rust로 작성 (고성능)
- 온프레미스 & 클라우드 지원
- 강력한 필터링 기능

**장점**:
- 매우 빠른 속도
- 메모리 효율적
- 복잡한 payload 필터링
- Docker로 쉬운 배포

**단점**:
- 별도 서버 설치 필요
- GraphQL 미지원
- 상대적으로 작은 커뮤니티

**코드 예시**:
```python
from qdrant_client import QdrantClient
from qdrant_client.models import Distance, VectorParams

client = QdrantClient(host="localhost", port=6333)

# 컬렉션 생성
client.create_collection(
    collection_name="documents",
    vectors_config=VectorParams(size=384, distance=Distance.COSINE)
)

# 벡터 저장
client.upsert(
    collection_name="documents",
    points=[{
        "id": 1,
        "vector": [0.1, 0.2, 0.3],
        "payload": {"text": "문서 내용", "category": "tech"}
    }]
)

# 검색 (필터링 포함)
results = client.search(
    collection_name="documents",
    query_vector=[0.1, 0.2, 0.3],
    query_filter={"category": "tech"},
    limit=5
)
```

**적합한 경우**:
- 온프레미스 배포
- 고성능 필요
- 복잡한 메타데이터 필터링

---

### 2.3 Weaviate

**특징**:
- Go로 작성
- GraphQL API 지원
- 하이브리드 검색 (벡터 + 키워드)

**장점**:
- GraphQL 쿼리 지원
- 강력한 스키마 관리
- 모듈식 아키텍처
- RESTful + GraphQL API

**단점**:
- 상대적으로 높은 메모리 사용
- 설정 복잡도
- Qdrant보다 느림

**코드 예시**:
```python
import weaviate

client = weaviate.Client("http://localhost:8080")

# 스키마 정의
schema = {
    "class": "Document",
    "properties": [
        {"name": "content", "dataType": ["text"]},
        {"name": "category", "dataType": ["string"]}
    ]
}
client.schema.create_class(schema)

# 객체 추가
client.data_object.create(
    class_name="Document",
    data_object={"content": "문서 내용", "category": "tech"},
    vector=[0.1, 0.2, 0.3]
)

# GraphQL 검색
result = client.query.get(
    "Document", ["content", "category"]
).with_near_vector({
    "vector": [0.1, 0.2, 0.3]
}).with_limit(5).do()
```

**적합한 경우**:
- GraphQL 생태계
- 복잡한 데이터 스키마
- 하이브리드 검색 필요

---

### 2.4 Chroma

**특징**:
- Python 네이티브
- 로컬 파일 기반
- 설치 없이 사용 가능

**장점**:
- 가장 쉬운 설치 (pip install)
- 서버 불필요
- 빠른 프로토타이핑
- LangChain 통합 우수

**단점**:
- 프로덕션 성능 부족
- 스케일링 제한적
- 고급 기능 부족

**코드 예시**:
```python
import chromadb

client = chromadb.Client()
collection = client.create_collection("documents")

# 문서 추가
collection.add(
    documents=["문서 내용 1", "문서 내용 2"],
    metadatas=[{"category": "tech"}, {"category": "news"}],
    ids=["id1", "id2"]
)

# 검색
results = collection.query(
    query_texts=["검색 쿼리"],
    n_results=5
)
```

**적합한 경우**:
- 학습/개발 단계
- PoC (Proof of Concept)
- 로컬 테스트

---

## 3. GraphQL이란?

### 정의
GraphQL은 API를 위한 쿼리 언어이자 런타임으로, 클라이언트가 필요한 데이터를 정확히 요청할 수 있게 해주는 기술

### REST API vs GraphQL

**REST API**:
```
GET /users/123
GET /users/123/posts
GET /users/123/friends
```
→ 3번의 요청 필요

**GraphQL**:
```graphql
{
  user(id: 123) {
    name
    posts {
      title
    }
    friends {
      name
    }
  }
}
```
→ 1번의 요청으로 모든 데이터 취득

### Weaviate에서의 GraphQL 활용

```graphql
{
  Get {
    Document(
      nearVector: {
        vector: [0.1, 0.2, 0.3]
      }
      limit: 5
    ) {
      content
      category
      _additional {
        distance
      }
    }
  }
}
```

**장점**:
- 필요한 필드만 선택적으로 가져옴
- 한 번의 요청으로 복잡한 데이터 조회
- 타입 안정성

---

## 4. 종합 비교표

| 항목 | Pinecone | Qdrant | Weaviate | Chroma |
|------|----------|--------|----------|--------|
| **배포 방식** | 클라우드 전용 | 온프레미스/클라우드 | 온프레미스/클라우드 | 로컬 |
| **언어** | - | Rust | Go | Python |
| **속도** | 빠름 | 가장 빠름 | 빠름 | 보통 |
| **메모리 효율** | 좋음 | 우수 | 보통 | 낮음 |
| **설치 난이도** | 없음 (SaaS) | 중간 | 중간 | 쉬움 |
| **GraphQL** | ❌ | ❌ | ✅ | ❌ |
| **하이브리드 검색** | ✅ | ✅ | ✅ | ❌ |
| **필터링** | 기본 | 강력 | 강력 | 기본 |
| **비용** | 유료 | 무료/유료 | 무료/유료 | 무료 |
| **프로덕션** | ✅ | ✅ | ✅ | ⚠️ |
| **학습용** | ⚠️ | ✅ | ✅ | ✅ |

---

## 5. 선택 가이드

### 학습/개발 단계
```
Chroma → 가장 쉬움
```

### 중소규모 프로덕션
```
Qdrant → 성능 우선
Weaviate → 기능 우선
```

### 대규모 프로덕션
```
Pinecone → 관리형 선호
Qdrant → 온프레미스 선호
```

### 특수 요구사항
```
GraphQL 필요 → Weaviate
최고 성능 → Qdrant
운영 부담 최소화 → Pinecone
빠른 프로토타이핑 → Chroma
```

---

## 6. 실무 추천

**학습 로드맵**:
1. Chroma로 벡터 DB 개념 학습
2. Qdrant로 프로덕션 수준 구현
3. 필요 시 Pinecone/Weaviate 검토

**현재 환경 (RTX 4060, 8GB VRAM)**:
- 로컬 개발: Chroma
- 실전 배포: Qdrant (Docker)

---

## 7. 설치 가이드

### Chroma (가장 쉬움)
```bash
pip install chromadb
```

### Qdrant (Docker)
```bash
docker run -p 6333:6333 qdrant/qdrant
pip install qdrant-client
```

### Weaviate (Docker)
```bash
docker run -d -p 8080:8080 semitechnologies/weaviate:latest
pip install weaviate-client
```

### Pinecone (클라우드)
```bash
pip install pinecone-client
# https://www.pinecone.io 에서 API 키 발급
```
```